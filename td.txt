# Análisis del código Tower Defense ZX Spectrum 48K

## VARIABLES

- a: Dato leído (usado en la definición de UDGs)
- b: Bucle para colocar ciudadanos (1 a 10)
- c: Array para almacenar posiciones de ciudadanos
- d: Bucle para colocar ladrillos (1 a 2)
- e: Bucle para colocar torretas (1 a 3)
- f: Bucle para generar zombies (1 a 10)
- g: Bucle para mover zombies
- h: Bucle para comprobar ladrillos (no implementado en el código actual)
- j: Bucle para comprobar torretas
- k: Tecla pulsada
- l: Array para almacenar posiciones de ladrillos
- m: Matriz que representa el mapa del juego (22x32)
  - 0: Vacío
  - 1: Ciudadano
  - 2: Ladrillo
  - 3: Torreta
  - 4-6: Zombie
- n: Bucle para definir UDGs
- oldx, oldy: Posición anterior del zombie
- score: Puntuación del jugador
- t: Array para almacenar información de torretas
- z: Array para almacenar información de zombies
- te: Índice de la torreta en el bucle de dibujo
- level: Nivel actual del juego (inicializado pero no utilizado)
- cursorx, cursory: Posición del cursor en la pantalla
- ocupado: Flag para indicar si una celda está ocupada

## SUBRUTINAS

### 2000 a 2060 - Colocar ciudadanos
Coloca 10 ciudadanos aleatoriamente en el mapa y actualiza las matrices c y m.
Variables auxiliares: b - bucle de 1 a 10

### 3000 a 3090 - Colocar ladrillos
Permite al jugador colocar 2 ladrillos en el mapa usando el cursor.
Variables auxiliares: d - bucle de 1 a 2

### 4000 a 4090 - Colocar torretas
Permite al jugador colocar 3 torretas en el mapa usando el cursor.
Variables auxiliares: e - bucle de 1 a 3

### 5000 a 5060 - Generar zombies
Genera 10 zombies en el borde derecho del mapa con posiciones verticales aleatorias.
Variables auxiliares: f - bucle de 1 a 10

### 7000 a 7040 - Mover zombies
Mueve todos los zombies una posición a la izquierda en cada iteración.
Variables auxiliares: g - bucle de 1 a 10

### 7100 a 7120 - Comprobar colisiones
Placeholder para implementar la detección de colisiones (no implementado en el código actual).

### 7200 a 7210 - Actualizar puntuación
Muestra la puntuación actual en la pantalla.

### 7300 a 7370 - Controles del jugador
Maneja las entradas del teclado para el control del juego (no implementado completamente).

### 8000 a 8020 - Dibujar cursor
Dibuja el cursor en la pantalla.

### 8050 a 8070 - Borrar cursor
Borra el cursor de la pantalla y redibuja el contenido si es necesario.

### 8100 a 8120 - Dibujar torreta
Dibuja una torreta en la posición especificada.

### 8150 a 8170 - Dibujar zombie
Dibuja un zombie en la posición especificada.

### 8200 a 8260 - Manejar pulsaciones de teclas
Maneja las pulsaciones de teclas para mover el cursor durante la colocación de objetos.

### 8400 a 8530 - Comprobar y redibujar ladrillo o torreta
Comprueba si hay un ladrillo o torreta en la posición actual y lo redibuja si es necesario.

### 8600 a 8620 - Comprobar si la celda está ocupada
Verifica si una celda del mapa está ocupada.

## BUCLE PRINCIPAL

### 1 a 7 - Comentarios iniciales
Explica las variables y su uso en el juego.

### 10 a 20 - Inicializaciones generales
Define las dimensiones de los arrays, inicializa variables y configura los colores de la pantalla.

### 100 a 220 - Inicialización de UDGs (User Defined Graphics)
Define los gráficos personalizados para los diferentes elementos del juego (ciudadanos, ladrillos, zombies, torretas).

### 1000 a 1050 - Inicialización del juego
Llama a las subrutinas para colocar ciudadanos, ladrillos, torretas y generar zombies.

### 6000 a 6030 - Bucle principal del juego
Ejecuta las subrutinas principales del juego en un bucle continuo:
- Mover zombies
- Comprobar colisiones
- Actualizar puntuación
- Manejar controles del jugador
Termina el juego si la puntuación supera 1000.

### 9000 a 9020 - Fin del juego
Muestra la pantalla de "Game Over" con la puntuación final y reinicia el juego al pulsar una tecla.

## NOTAS ADICIONALES

- El juego utiliza gráficos personalizados (UDGs) para representar los diferentes elementos.
- La lógica de colisiones y algunas partes del control del jugador no están completamente implementadas.
- El sistema de niveles está inicializado pero no se utiliza en el código actual.
- El juego termina cuando el jugador alcanza una puntuación de 1000, pero no hay implementación visible de cómo se incrementa la puntuación.