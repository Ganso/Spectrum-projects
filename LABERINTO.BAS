10 REM LABERINTO.BAS - Juego Laberinto para ZX Spectrum
20 RANDOMIZE
30 DIM M(40,40)
31 DIM V(40,40)
32 DIM T(40,40)
33 DIM Z(600)     :  REM Pila para generación de laberinto (coordenadas combinadas)
34 DIM F(4)       :  REM Array para movimientos disponibles
60 FOR I=1 TO 40: FOR J=1 TO 40: LET M(I,J)=15: LET V(I,J)=0: LET T(I,J)=0: NEXT J: NEXT I
70 LET SP=1: LET Z(1)=1: LET V(1,1)=1
80 GOSUB 5000
90 LET T(40,40)=2
100 REM Coloca 20 ítems aleatorios
110 LET I=0
120 LET A=INT(RND*40)+1: LET B=INT(RND*40)+1
130 IF (A=1 AND B=1) OR (A=40 AND B=40) THEN GOTO 120
140 IF T(A,B)<>0 THEN GOTO 120
150 LET T(A,B)=1: LET I=I+1
160 IF I<20 THEN GOTO 120
170 REM Genera gráficos UDG con patrones representativos
180 FOR I=0 TO 7: LET X=INT(RND*64) OR 16: POKE 22528+I,X: NEXT I: : REM UDG piso (CHR$(0))
190 FOR I=0 TO 7: LET X=INT(RND*64) OR 128: POKE 22536+I,X: NEXT I: : REM UDG muro (CHR$(1))
200 FOR I=0 TO 7: LET X=INT(RND*64) OR 32: POKE 22544+I,X: NEXT I: : REM UDG protagonista (CHR$(2))
210 FOR I=0 TO 7: LET X=INT(RND*64) OR 64: POKE 22552+I,X: NEXT I: : REM UDG ítem (CHR$(3))
220 FOR I=0 TO 7: LET X=INT(RND*64) OR 96: POKE 22560+I,X: NEXT I: : REM UDG salida (CHR$(4))
230 LET PX=1: LET PY=1: LET P=0: LET G=0
240 INK 7: PAPER 0: BORDER 0: CLS
250 REM Bucle principal del juego
260 LET K$=INKEY$
270 LET NX=PX: LET NY=PY
280 IF K$="Q" THEN LET NX=PX-1: IF K$="P" THEN LET NX=PX+1
290 IF K$="O" THEN LET NY=PY-1: IF K$="A" THEN LET NY=PY+1
300 IF NX<1 OR NY<1 OR NX+1>80 OR NY+1>80 THEN GOTO 350
310 LET TX=NX: LET TY=NY: GOSUB 7000: IF P1=0 THEN GOTO 350
320 LET PX=NX: LET PY=NY
330 LET ACell=INT((PX-1)/2)+1: LET BCell=INT((PY-1)/2)+1
331 IF T(ACell,BCell)=1 THEN LET T(ACell,BCell)=0: LET P=P+1: IF T(ACell,BCell)=2 THEN LET G=1
340 GOSUB 6000
350 IF G=1 THEN GOTO 390
360 FOR D=1 TO 50: NEXT D
370 GOTO 260
380 REM Paso intermedio
390 PRINT "FIN DE LA FASE. PUNTOS=";P: PAUSE 2000: STOP
5000 REM Genera laberinto (DFS con backtracking, usando pila Z y array F para movimientos)
5010 LET L=SP
5020 IF L=0 THEN RETURN
5030 LET C=Z(L)
5040 LET Y=INT((C-1)/40)+1
5050 LET X=C - (Y-1)*40
5060 LET N1=0
5070 IF Y>1 THEN IF V(X,Y-1)=0 THEN LET N1=N1+1: LET F(N1)=(Y-2)*40+X
5080 IF X<40 THEN IF V(X+1,Y)=0 THEN LET N1=N1+1: LET F(N1)=(Y-1)*40+(X+1)
5090 IF Y<40 THEN IF V(X,Y+1)=0 THEN LET N1=N1+1: LET F(N1)=Y*40+X
5100 IF X>1 THEN IF V(X-1,Y)=0 THEN LET N1=N1+1: LET F(N1)=(Y-1)*40+(X-1)
5110 IF N1>0 THEN GOTO 5140
5120 LET SP=SP-1
5130 GOTO 5150
5140 LET R=INT(RND*N1)+1: LET NCoord=F(R)
5150 REM Calcular coordenadas del vecino seleccionado
5160 LET NY=INT((NCoord-1)/40)+1
5170 LET NX=NCoord - (NY-1)*40
5180 REM Quitar muros entre (X,Y) y (NX,NY)
5190 IF NY<Y THEN LET M(X,Y)=M(X,Y)-1: LET M(X,NY)=M(X,NY)-4: GOTO 5200
5200 IF NX>X THEN LET M(X,Y)=M(X,Y)-2: LET M(NX,Y)=M(NX,Y)-8: GOTO 5210
5210 IF NY>Y THEN LET M(X,Y)=M(X,Y)-4: LET M(X,NY)=M(X,NY)-1: GOTO 5220
5220 IF NX<X THEN LET M(X,Y)=M(X,Y)-8: LET M(NX,Y)=M(NX,Y)-2
5230 REM Marcar vecino como visitado y apilar
5240 LET V(NX,NY)=1
5250 LET SP=SP+1: LET Z(SP)=NCoord
5260 GOTO 5010
6000 REM Dibuja pantalla (viewport centrado en el protagonista)
6010 CLS
6020 PRINT "Pts:";P
6030 FOR Y=1 TO 23
6040 LET L$=""
6050 FOR X=1 TO 32
6060 LET MX=PX+X-16: LET MY=PY+Y-12
6070 LET CI=INT((MX-1)/2)+1: LET CJ=INT((MY-1)/2)+1
6080 IF MX=PX AND MY=PY THEN LET C$=CHR$(2): GOTO 6090
6090 IF T(CI,CJ)=1 THEN LET C$=CHR$(3): GOTO 6100
6100 IF T(CI,CJ)=2 THEN LET C$=CHR$(4): GOTO 6110
6110 IF M(CI,CJ) AND 1 THEN LET C$=CHR$(1): GOTO 6120
6120 LET C$=CHR$(0)
6130 LET L$=L$+C$
6140 NEXT X
6150 PRINT L$
6160 NEXT Y
6170 RETURN
7000 REM Subrutina de colisión
7010 LET CI=INT((TX-1)/2)+1: LET CJ=INT((TY-1)/2)+1
7020 IF CI<1 OR CI>40 OR CJ<1 OR CJ>40 THEN LET P1=0: RETURN
7030 IF T(CI,CJ)<>0 THEN LET P1=1: RETURN
7040 LET P1=1: RETURN